
# 📌 백준 시간·공간 복잡도 판단 

백준 문제를 풀 때 **시간 초과 / 메모리 초과**를 피하기 위한  실전용 판단 기준 정리본

---

## ✅ 문제 열자마자 체크할 것

- 입력 크기 `N`
- 시간 제한 (초)
- 메모리 제한 (MB)
- **값의 범위** (카운팅 정렬 여부 판단 핵심)

---

## ⏱ 시간 복잡도 기준 (필수 암기)

| 입력 크기 N | 허용 복잡도 |
|------------|------------|
| N ≤ 100 | O(N³) |
| N ≤ 1,000 | O(N²) |
| N ≤ 100,000 | O(N log N) |
| N ≤ 1,000,000 | O(N) |
| N ≥ 10,000,000 | 수학 / 규칙 / 카운팅 |

> 💡 Java 기준  
> 1초 ≈ **1e7 ~ 5e7 연산** (보수적으로 판단)

---

## 💾 메모리 사용 감각

### 기본 자료형
- `int` : 4B
- `long` : 8B

### 배열 기준
- `int[1_000_000]` ≈ **4MB**
- `int[2_000_000]` ≈ **8MB (위험)**

📌 **메모리 제한 8MB**
- int 배열 **1개가 한계**
- 배열 여러 개 사용 시 메모리 초과 가능성 큼

---

## 🔤 입력 방식 선택 기준

입력 개수 많다? (`N ≥ 100,000`)

- ❌ `Scanner`
- ⭕ `BufferedReader + StringBuilder`

---

## 🧠 알고리즘 선택 기준

- 정렬 + N 큼 → `O(N log N)` 가능 여부 확인
- 값 범위 작음 → **카운팅 정렬**
- 존재 여부 확인 → `HashSet` / 이진 탐색
- 전부 비교 → 브루트포스 (N 작을 때만)

---

<br><br>

# 📌 Java Collections 시간/공간 복잡도 정리

## 1. List

| 자료구조 | 접근 | 탐색/검색 | 삽입/삭제 (중간) | 삽입/삭제 (끝) | 공간 복잡도 |
|-----------|-------|------------|-----------------|----------------|-------------|
| ArrayList | O(1)  | O(n)       | O(n)            | O(1) (amortized) | O(n)        |
| LinkedList| O(n)  | O(n)       | O(1) (노드 알고 있을 때) | O(1) | O(n)        |

---

## 2. Set

| 자료구조 | 삽입 | 삭제 | 탐색 | 정렬 | 공간 복잡도 |
|-----------|------|------|------|------|-------------|
| HashSet   | O(1) | O(1) | O(1) | X    | O(n)        |
| TreeSet   | O(log n) | O(log n) | O(log n) | 자동 정렬 | O(n)       |
| LinkedHashSet | O(1) | O(1) | O(1) | 순서 유지 | O(n) |

> ⚠️ HashSet/LinkedHashSet은 순서 보장 안 함 (LinkedHashSet은 입력 순서 유지)

---

## 3. Map

| 자료구조 | 삽입 | 삭제 | 탐색 | 정렬 | 공간 복잡도 |
|-----------|------|------|------|------|-------------|
| HashMap   | O(1) | O(1) | O(1) | X    | O(n)        |
| TreeMap   | O(log n) | O(log n) | O(log n) | 키 기준 정렬 | O(n) |
| LinkedHashMap | O(1) | O(1) | O(1) | 순서 유지 | O(n) |

---

## 4. 정렬 관련

| 정렬 방법 | 시간 복잡도 | 공간 복잡도 | 특징 |
|-----------|------------|-------------|------|
| Arrays.sort / Collections.sort (객체) | O(n log n) | O(n) (병합 정렬 기반) | 안정 정렬 |
| Arrays.sort (기본형) | O(n log n) | O(log n) | 불안정 정렬, Dual-Pivot QuickSort |
| TreeSet / TreeMap | O(log n) 삽입/삭제/탐색 | O(n) | 키 자동 정렬 |

---

## 5. 참고

- n = 원소 개수, L = 문자열 길이 (문자열 비교 포함 시)
- **Hash 기반** 자료구조 → 평균 O(1), 최악 O(n)  
- **Tree 기반** 자료구조 → 항상 O(log n)

